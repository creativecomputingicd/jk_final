{
  "version": 3,
  "sources": ["../../three-csgmesh/dist/client/CSGMesh.js"],
  "sourcesContent": ["/**\n * GitHub Repo : https://github.com/Sean-Bradley/THREE-CSGMesh\n * License : MIT\n *\n * Original work copyright (c) 2011 Evan Wallace (http://madebyevan.com/), under the MIT license.\n * THREE.js rework by thrax\n *\n * # class CSG\n * Holds a binary space partition tree representing a 3D solid. Two solids can\n * be combined using the `union()`, `subtract()`, and `intersect()` methods.\n *\n * Differences Copyright 2020-2022 Sean Bradley : https://sbcode.net/threejs/\n * - Started with CSGMesh.js and csg-lib.js from https://github.com/manthrax/THREE-CSGMesh\n * - Converted to TypeScript by adding type annotations to all variables\n * - Converted var to const and let\n * - Some Refactoring\n * - support for three r141\n * - updated for three r150\n */\nimport * as THREE from 'three';\n// # class CSG\n// Holds a binary space partition tree representing a 3D solid. Two solids can\n// be combined using the `union()`, `subtract()`, and `intersect()` methods.\nclass CSG {\n    constructor() {\n        this.polygons = [];\n    }\n    clone() {\n        let csg = new CSG();\n        csg.polygons = this.polygons.map((p) => p.clone());\n        return csg;\n    }\n    toPolygons() {\n        return this.polygons;\n    }\n    union(csg) {\n        let a = new Node(this.clone().polygons);\n        let b = new Node(csg.clone().polygons);\n        a.clipTo(b);\n        b.clipTo(a);\n        b.invert();\n        b.clipTo(a);\n        b.invert();\n        a.build(b.allPolygons());\n        return CSG.fromPolygons(a.allPolygons());\n    }\n    subtract(csg) {\n        let a = new Node(this.clone().polygons);\n        let b = new Node(csg.clone().polygons);\n        a.invert();\n        a.clipTo(b);\n        b.clipTo(a);\n        b.invert();\n        b.clipTo(a);\n        b.invert();\n        a.build(b.allPolygons());\n        a.invert();\n        return CSG.fromPolygons(a.allPolygons());\n    }\n    intersect(csg) {\n        let a = new Node(this.clone().polygons);\n        let b = new Node(csg.clone().polygons);\n        a.invert();\n        b.clipTo(a);\n        b.invert();\n        a.clipTo(b);\n        b.clipTo(a);\n        a.build(b.allPolygons());\n        a.invert();\n        return CSG.fromPolygons(a.allPolygons());\n    }\n    // Return a new CSG solid with solid and empty space switched. This solid is\n    // not modified.\n    inverse() {\n        let csg = this.clone();\n        csg.polygons.forEach((p) => p.flip());\n        return csg;\n    }\n}\n// Construct a CSG solid from a list of `Polygon` instances.\nCSG.fromPolygons = function (polygons) {\n    let csg = new CSG();\n    csg.polygons = polygons;\n    return csg;\n};\nCSG.fromGeometry = function (geom, objectIndex) {\n    let polys = [];\n    let posattr = geom.attributes.position;\n    let normalattr = geom.attributes.normal;\n    let uvattr = geom.attributes.uv;\n    let colorattr = geom.attributes.color;\n    let index;\n    if (geom.index)\n        index = geom.index.array;\n    else {\n        index = new Array((posattr.array.length / posattr.itemSize) | 0);\n        for (let i = 0; i < index.length; i++)\n            index[i] = i;\n    }\n    let triCount = (index.length / 3) | 0;\n    polys = new Array(triCount);\n    for (let i = 0, pli = 0, l = index.length; i < l; i += 3, pli++) {\n        let vertices = new Array(3);\n        for (let j = 0; j < 3; j++) {\n            let vi = index[i + j];\n            let vp = vi * 3;\n            let vt = vi * 2;\n            let x = posattr.array[vp];\n            let y = posattr.array[vp + 1];\n            let z = posattr.array[vp + 2];\n            let nx = normalattr.array[vp];\n            let ny = normalattr.array[vp + 1];\n            let nz = normalattr.array[vp + 2];\n            //let u = uvattr.array[vt]\n            //let v = uvattr.array[vt + 1]\n            vertices[j] = new Vertex({\n                x: x,\n                y: y,\n                z: z,\n            }, {\n                x: nx,\n                y: ny,\n                z: nz,\n            }, uvattr &&\n                {\n                    x: uvattr.array[vt],\n                    y: uvattr.array[vt + 1],\n                    z: 0,\n                }, colorattr &&\n                {\n                    x: colorattr.array[vt],\n                    y: colorattr.array[vt + 1],\n                    z: colorattr.array[vt + 2],\n                });\n        }\n        polys[pli] = new Polygon(vertices, objectIndex);\n    }\n    return CSG.fromPolygons(polys);\n};\nCSG.ttvv0 = new THREE.Vector3();\nCSG.tmpm3 = new THREE.Matrix3();\nCSG.fromMesh = function (mesh, objectIndex) {\n    let csg = CSG.fromGeometry(mesh.geometry, objectIndex);\n    CSG.tmpm3.getNormalMatrix(mesh.matrix);\n    for (let i = 0; i < csg.polygons.length; i++) {\n        let p = csg.polygons[i];\n        for (let j = 0; j < p.vertices.length; j++) {\n            let v = p.vertices[j];\n            v.pos.copy(CSG.ttvv0\n                .copy(new THREE.Vector3(v.pos.x, v.pos.y, v.pos.z))\n                .applyMatrix4(mesh.matrix));\n            v.normal.copy(CSG.ttvv0\n                .copy(new THREE.Vector3(v.normal.x, v.normal.y, v.normal.z))\n                .applyMatrix3(CSG.tmpm3));\n        }\n    }\n    return csg;\n};\nCSG.nbuf3 = (ct) => {\n    return {\n        top: 0,\n        array: new Float32Array(ct),\n        write: function (v) {\n            this.array[this.top++] = v.x;\n            this.array[this.top++] = v.y;\n            this.array[this.top++] = v.z;\n        },\n    };\n};\nCSG.nbuf2 = (ct) => {\n    return {\n        top: 0,\n        array: new Float32Array(ct),\n        write: function (v) {\n            this.array[this.top++] = v.x;\n            this.array[this.top++] = v.y;\n        },\n    };\n};\nCSG.toGeometry = function (csg) {\n    let ps = csg.polygons;\n    let geom;\n    let g2;\n    let triCount = 0;\n    ps.forEach((p) => (triCount += p.vertices.length - 2));\n    geom = new THREE.BufferGeometry();\n    let vertices = CSG.nbuf3(triCount * 3 * 3);\n    let normals = CSG.nbuf3(triCount * 3 * 3);\n    let uvs;\n    let colors;\n    const grps = {};\n    ps.forEach((p) => {\n        let pvs = p.vertices;\n        let pvlen = pvs.length;\n        if (p.shared !== undefined) {\n            if (!grps[p.shared])\n                grps[p.shared] = [];\n        }\n        if (pvlen) {\n            if (pvs[0].color !== undefined) {\n                if (!colors)\n                    colors = CSG.nbuf3(triCount * 3 * 3);\n            }\n            if (pvs[0].uv !== undefined) {\n                if (!uvs)\n                    uvs = CSG.nbuf2(triCount * 2 * 3);\n            }\n        }\n        for (let j = 3; j <= pvlen; j++) {\n            p.shared !== undefined &&\n                grps[p.shared].push(vertices.top / 3, vertices.top / 3 + 1, vertices.top / 3 + 2);\n            vertices.write(pvs[0].pos);\n            vertices.write(pvs[j - 2].pos);\n            vertices.write(pvs[j - 1].pos);\n            normals.write(pvs[0].normal);\n            normals.write(pvs[j - 2].normal);\n            normals.write(pvs[j - 1].normal);\n            uvs &&\n                pvs[0].uv &&\n                (uvs.write(pvs[0].uv) || uvs.write(pvs[j - 2].uv) || uvs.write(pvs[j - 1].uv));\n            colors &&\n                (colors.write(pvs[0].color) ||\n                    colors.write(pvs[j - 2].color) ||\n                    colors.write(pvs[j - 1].color));\n        }\n    });\n    geom.setAttribute('position', new THREE.BufferAttribute(vertices.array, 3));\n    geom.setAttribute('normal', new THREE.BufferAttribute(normals.array, 3));\n    uvs && geom.setAttribute('uv', new THREE.BufferAttribute(uvs.array, 2));\n    colors && geom.setAttribute('color', new THREE.BufferAttribute(colors.array, 3));\n    if (Object.keys(grps).length) {\n        let index = [];\n        let gbase = 0;\n        for (let gi = 0; gi < Object.keys(grps).length; gi++) {\n            const key = Number(Object.keys(grps)[gi]);\n            geom.addGroup(gbase, grps[key].length, gi);\n            gbase += grps[key].length;\n            index = index.concat(grps[key]);\n        }\n        geom.setIndex(index);\n    }\n    g2 = geom;\n    return geom;\n};\nCSG.toMesh = function (csg, toMatrix, toMaterial) {\n    let geom = CSG.toGeometry(csg);\n    let inv = new THREE.Matrix4().copy(toMatrix).invert();\n    geom.applyMatrix4(inv);\n    geom.computeBoundingSphere();\n    geom.computeBoundingBox();\n    let m = new THREE.Mesh(geom, toMaterial);\n    m.matrix.copy(toMatrix);\n    m.matrix.decompose(m.position, m.quaternion, m.scale);\n    m.rotation.setFromQuaternion(m.quaternion);\n    m.updateMatrixWorld();\n    m.castShadow = m.receiveShadow = true;\n    return m;\n};\n// # class Vector\n// Represents a 3D vector.\n//\n// Example usage:\n//\n//     new CSG.Vector(1, 2, 3);\nclass Vector {\n    constructor(x = 0, y = 0, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    copy(v) {\n        this.x = v.x;\n        this.y = v.y;\n        this.z = v.z;\n        return this;\n    }\n    clone() {\n        return new Vector(this.x, this.y, this.z);\n    }\n    negate() {\n        this.x *= -1;\n        this.y *= -1;\n        this.z *= -1;\n        return this;\n    }\n    add(a) {\n        this.x += a.x;\n        this.y += a.y;\n        this.z += a.z;\n        return this;\n    }\n    sub(a) {\n        this.x -= a.x;\n        this.y -= a.y;\n        this.z -= a.z;\n        return this;\n    }\n    times(a) {\n        this.x *= a;\n        this.y *= a;\n        this.z *= a;\n        return this;\n    }\n    dividedBy(a) {\n        this.x /= a;\n        this.y /= a;\n        this.z /= a;\n        return this;\n    }\n    lerp(a, t) {\n        return this.add(Vector.tv0.copy(a).sub(this).times(t));\n    }\n    unit() {\n        return this.dividedBy(this.length());\n    }\n    length() {\n        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));\n    }\n    normalize() {\n        return this.unit();\n    }\n    cross(b) {\n        let a = this;\n        const ax = a.x, ay = a.y, az = a.z;\n        const bx = b.x, by = b.y, bz = b.z;\n        this.x = ay * bz - az * by;\n        this.y = az * bx - ax * bz;\n        this.z = ax * by - ay * bx;\n        return this;\n    }\n    dot(b) {\n        return this.x * b.x + this.y * b.y + this.z * b.z;\n    }\n}\n//Temporaries used to avoid internal allocation..\nVector.tv0 = new Vector();\nVector.tv1 = new Vector();\n// # class Vertex\n// Represents a vertex of a polygon. Use your own vertex class instead of this\n// one to provide additional features like texture coordinates and vertex\n// colors. Custom vertex classes need to provide a `pos` property and `clone()`,\n// `flip()`, and `interpolate()` methods that behave analogous to the ones\n// defined by `CSG.Vertex`. This class provides `normal` so convenience\n// functions like `CSG.sphere()` can return a smooth vertex normal, but `normal`\n// is not used anywhere else.\nclass Vertex {\n    constructor(pos, normal, uv, color) {\n        this.pos = new Vector().copy(pos);\n        this.normal = new Vector().copy(normal);\n        uv && (this.uv = new Vector().copy(uv)) && (this.uv.z = 0);\n        color && (this.color = new Vector().copy(color));\n    }\n    clone() {\n        return new Vertex(this.pos, this.normal, this.uv, this.color);\n    }\n    // Invert all orientation-specific data (e.g. vertex normal). Called when the\n    // orientation of a polygon is flipped.\n    flip() {\n        this.normal.negate();\n    }\n    // Create a new vertex between this vertex and `other` by linearly\n    // interpolating all properties using a parameter of `t`. Subclasses should\n    // override this to interpolate additional properties.\n    interpolate(other, t) {\n        return new Vertex(this.pos.clone().lerp(other.pos, t), this.normal.clone().lerp(other.normal, t), this.uv && other.uv && this.uv.clone().lerp(other.uv, t), this.color && other.color && this.color.clone().lerp(other.color, t));\n    }\n}\n// # class Plane\n// Represents a plane in 3D space.\nclass Plane {\n    constructor(normal, w) {\n        this.normal = normal;\n        this.w = w;\n    }\n    clone() {\n        return new Plane(this.normal.clone(), this.w);\n    }\n    flip() {\n        this.normal.negate();\n        this.w = -this.w;\n    }\n    // Split `polygon` by this plane if needed, then put the polygon or polygon\n    // fragments in the appropriate lists. Coplanar polygons go into either\n    // `coplanarFront` or `coplanarBack` depending on their orientation with\n    // respect to this plane. Polygons in front or in back of this plane go into\n    // either `front` or `back`.\n    splitPolygon(polygon, coplanarFront, coplanarBack, front, back) {\n        const COPLANAR = 0;\n        const FRONT = 1;\n        const BACK = 2;\n        const SPANNING = 3;\n        // Classify each point as well as the entire polygon into one of the above\n        // four classes.\n        let polygonType = 0;\n        let types = [];\n        for (let i = 0; i < polygon.vertices.length; i++) {\n            let t = this.normal.dot(polygon.vertices[i].pos) - this.w;\n            let type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\n            polygonType |= type;\n            types.push(type);\n        }\n        // Put the polygon in the correct list, splitting it when necessary.\n        switch (polygonType) {\n            case COPLANAR:\n                ;\n                (this.normal.dot(polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\n                break;\n            case FRONT:\n                front.push(polygon);\n                break;\n            case BACK:\n                back.push(polygon);\n                break;\n            case SPANNING:\n                let f = [], b = [];\n                for (let i = 0; i < polygon.vertices.length; i++) {\n                    let j = (i + 1) % polygon.vertices.length;\n                    let ti = types[i], tj = types[j];\n                    let vi = polygon.vertices[i], vj = polygon.vertices[j];\n                    if (ti != BACK)\n                        f.push(vi);\n                    if (ti != FRONT)\n                        b.push(ti != BACK ? vi.clone() : vi);\n                    if ((ti | tj) == SPANNING) {\n                        let t = (this.w - this.normal.dot(vi.pos)) /\n                            this.normal.dot(Vector.tv0.copy(vj.pos).sub(vi.pos));\n                        let v = vi.interpolate(vj, t);\n                        f.push(v);\n                        b.push(v.clone());\n                    }\n                }\n                if (f.length >= 3)\n                    front.push(new Polygon(f, polygon.shared));\n                if (b.length >= 3)\n                    back.push(new Polygon(b, polygon.shared));\n                break;\n        }\n    }\n}\n// `Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\n// point is on the plane.\nPlane.EPSILON = 1e-5;\nPlane.fromPoints = function (a, b, c) {\n    let n = Vector.tv0.copy(b).sub(a).cross(Vector.tv1.copy(c).sub(a)).normalize();\n    return new Plane(n.clone(), n.dot(a));\n};\n// # class Polygon\n// Represents a convex polygon. The vertices used to initialize a polygon must\n// be coplanar and form a convex loop. They do not have to be `Vertex`\n// instances but they must behave similarly (duck typing can be used for\n// customization).\n//\n// Each convex polygon has a `shared` property, which is shared between all\n// polygons that are clones of each other or were split from the same polygon.\n// This can be used to define per-polygon properties (such as surface color).\nclass Polygon {\n    constructor(vertices, shared) {\n        this.vertices = vertices;\n        this.shared = shared;\n        this.plane = Plane.fromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n    }\n    clone() {\n        return new Polygon(this.vertices.map((v) => v.clone()), this.shared);\n    }\n    flip() {\n        this.vertices.reverse().forEach((v) => v.flip());\n        this.plane.flip();\n    }\n}\n// # class Node\n// Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n// by picking a polygon to split along. That polygon (and all other coplanar\n// polygons) are added directly to that node and the other polygons are added to\n// the front and/or back subtrees. This is not a leafy BSP tree since there is\n// no distinction between internal and leaf nodes.\nclass Node {\n    constructor(polygons) {\n        this.polygons = [];\n        if (polygons)\n            this.build(polygons);\n    }\n    clone() {\n        let node = new Node();\n        node.plane = this.plane && this.plane.clone();\n        node.front = this.front && this.front.clone();\n        node.back = this.back && this.back.clone();\n        node.polygons = this.polygons.map((p) => p.clone());\n        return node;\n    }\n    // Convert solid space to empty space and empty space to solid space.\n    invert() {\n        for (let i = 0; i < this.polygons.length; i++)\n            this.polygons[i].flip();\n        this.plane && this.plane.flip();\n        this.front && this.front.invert();\n        this.back && this.back.invert();\n        let temp = this.front;\n        this.front = this.back;\n        this.back = temp;\n    }\n    // Recursively remove all polygons in `polygons` that are inside this BSP\n    // tree.\n    clipPolygons(polygons) {\n        if (!this.plane)\n            return polygons.slice();\n        let front = [], back = [];\n        for (let i = 0; i < polygons.length; i++) {\n            this.plane.splitPolygon(polygons[i], front, back, front, back);\n        }\n        if (this.front)\n            front = this.front.clipPolygons(front);\n        if (this.back)\n            back = this.back.clipPolygons(back);\n        else\n            back = [];\n        //return front;\n        return front.concat(back);\n    }\n    // Remove all polygons in this BSP tree that are inside the other BSP tree\n    // `bsp`.\n    clipTo(bsp) {\n        this.polygons = bsp.clipPolygons(this.polygons);\n        if (this.front)\n            this.front.clipTo(bsp);\n        if (this.back)\n            this.back.clipTo(bsp);\n    }\n    // Return a list of all polygons in this BSP tree.\n    allPolygons() {\n        let polygons = this.polygons.slice();\n        if (this.front)\n            polygons = polygons.concat(this.front.allPolygons());\n        if (this.back)\n            polygons = polygons.concat(this.back.allPolygons());\n        return polygons;\n    }\n    // Build a BSP tree out of `polygons`. When called on an existing tree, the\n    // new polygons are filtered down to the bottom of the tree and become new\n    // nodes there. Each set of polygons is partitioned using the first polygon\n    // (no heuristic is used to pick a good split).\n    build(polygons) {\n        if (!polygons.length)\n            return;\n        if (!this.plane)\n            this.plane = polygons[0].plane.clone();\n        let front = [], back = [];\n        for (let i = 0; i < polygons.length; i++) {\n            this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n        }\n        if (front.length) {\n            if (!this.front)\n                this.front = new Node();\n            this.front.build(front);\n        }\n        if (back.length) {\n            if (!this.back)\n                this.back = new Node();\n            this.back.build(back);\n        }\n    }\n}\nNode.fromJSON = function (json) {\n    return CSG.fromPolygons(json.polygons.map((p) => new Polygon(p.vertices.map((v) => new Vertex(v.pos, v.normal, v.uv)), p.shared)));\n};\nexport { CSG, Vertex, Vector, Polygon, Plane };\n// Return a new CSG solid representing space in either this solid or in the\n// solid `csg`. Neither this solid nor the solid `csg` are modified.\n//\n//     A.union(B)\n//\n//     +-------+            +-------+\n//     |       |            |       |\n//     |   A   |            |       |\n//     |    +--+----+   =   |       +----+\n//     +----+--+    |       +----+       |\n//          |   B   |            |       |\n//          |       |            |       |\n//          +-------+            +-------+\n//\n// Return a new CSG solid representing space in this solid but not in the\n// solid `csg`. Neither this solid nor the solid `csg` are modified.\n//\n//     A.subtract(B)\n//\n//     +-------+            +-------+\n//     |       |            |       |\n//     |   A   |            |       |\n//     |    +--+----+   =   |    +--+\n//     +----+--+    |       +----+\n//          |   B   |\n//          |       |\n//          +-------+\n//\n// Return a new CSG solid representing space both this solid and in the\n// solid `csg`. Neither this solid nor the solid `csg` are modified.\n//\n//     A.intersect(B)\n//\n//     +-------+\n//     |       |\n//     |   A   |\n//     |    +--+----+   =   +--+\n//     +----+--+    |       +--+\n//          |   B   |\n//          |       |\n//          +-------+\n//\n"],
  "mappings": "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",
  "names": []
}
